import { Project, SourceFile, SyntaxKind, Node } from 'ts-morph';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

interface Violation {
  file: string;
  line: number;
  column: number;
  rule: string;
  message: string;
  severity: 'error' | 'warning';
}

class ASTEnforcer {
  private project: Project;
  private violations: Violation[] = [];
  private rootDir: string;

  constructor() {
    this.rootDir = path.resolve(__dirname, '../..');
    this.project = new Project({
      tsConfigFilePath: path.join(this.rootDir, 'tsconfig.json'),
      skipAddingFilesFromTsConfig: false,
    });
  }

  private addViolation(
    file: SourceFile,
    node: Node,
    rule: string,
    message: string,
    severity: 'error' | 'warning' = 'error'
  ): void {
    const { line, column } = file.getLineAndColumnAtPos(node.getStart());
    this.violations.push({
      file: file.getFilePath().replace(this.rootDir + '/', ''),
      line,
      column,
      rule,
      message,
      severity,
    });
  }

  public enforce(): void {
    const sourceFiles = this.project.getSourceFiles([
      'src/**/*.ts',
      'src/**/*.tsx',
      '!src/**/*.test.ts',
      '!src/**/*.test.tsx',
      '!src/**/*.spec.ts',
      '!src/**/*.spec.tsx',
    ]);

    sourceFiles.forEach(file => {
      this.checkFile(file);
    });
  }

  private checkFile(file: SourceFile): void {
    this.checkTypeAnnotations(file);
    this.checkTsIgnoreComments(file);
    this.checkMotionLiterals(file);
    this.checkServerActionPatterns(file);
  }

  private checkTypeAnnotations(file: SourceFile): void {
    file.getDescendantsOfKind(SyntaxKind.TypeReference).forEach(typeRef => {
      const typeName = typeRef.getTypeName().getText();
      
      if (['any', 'unknown'].includes(typeName)) {
        this.addViolation(file, typeRef, 'no-any-unknown',
          `Type '${typeName}' bypasses type safety. Use specific types.`,
          'warning'
        );
      }
    });

    file.getDescendantsOfKind(SyntaxKind.AsExpression).forEach(asExpr => {
      const type = asExpr.getType();
      if (type.getText() === 'any') {
        this.addViolation(file, asExpr, 'no-type-assertion-any',
          'Type assertion to \'any\' bypasses type safety.',
          'error'
        );
      }
    });
  }

  private checkTsIgnoreComments(file: SourceFile): void {
    const fullText = file.getFullText();
    const lines = fullText.split('\n');
    
    lines.forEach((line, index) => {
      if (line.includes('@ts-ignore') || line.includes('@ts-expect-error')) {
        const match = line.match(/@ts-(ignore|expect-error)/);
        if (match) {
          const hasReason = line.includes(':') && line.split(':')[1]?.trim().length > 0;
          
          if (!hasReason) {
            this.violations.push({
              file: file.getFilePath().replace(this.rootDir + '/', ''),
              line: index + 1,
              column: line.indexOf(match[0]) + 1,
              rule: 'ts-suppress-requires-reason',
              message: `@ts-${match[1]} must include a reason comment`,
              severity: 'error',
            });
          }
        }
      }
    });
  }

  private checkMotionLiterals(file: SourceFile): void {
    const objects = file.getDescendantsOfKind(SyntaxKind.ObjectLiteralExpression);

    objects.forEach(obj => {
      const properties = obj.getProperties();
      const hasMotionProps = properties.some(prop => {
        // Handle different property node types safely
        try {
          let name: string | undefined;
          
          // PropertyAssignment and ShorthandPropertyAssignment have getName()
          if ('getName' in prop && typeof (prop as any).getName === 'function') {
            name = (prop as any).getName();
          } 
          // SpreadAssignment doesn't have getName(), skip it
          else if (prop.getKind() === SyntaxKind.SpreadAssignment) {
            return false;
          }
          // Fallback: try to get text
          else {
            const propText = prop.getText();
            const colonIndex = propText.indexOf(':');
            name = colonIndex > -1 ? propText.substring(0, colonIndex).trim() : propText;
          }
          
          return name ? ['initial', 'animate', 'exit', 'transition', 'variants'].includes(name) : false;
        } catch (error) {
          // Silently skip properties that can't be analyzed
          return false;
        }
      });

      if (hasMotionProps && !this.isMotionTokenReference(obj)) {
        this.addViolation(file, obj, 'no-magic-motion',
          'Inline motion configuration found. Use motion tokens from design system.',
          'error'
        );
      }
    });
  }

  private isMotionTokenReference(node: Node): boolean {
    const parent = node.getParent();
    if (!parent) return false;

    const text = parent.getText();
    return text.includes('motionTokens') || 
           text.includes('MotionKernel') ||
           text.includes('@motion');
  }

  private checkServerActionPatterns(file: SourceFile): void {
    const fileText = file.getFullText();
    const filePath = file.getFilePath();

    if (fileText.includes('"use server"') || fileText.includes("'use server'")) {
      const functions = file.getFunctions();
      
      functions.forEach(fn => {
        const returnType = fn.getReturnType();
        const returnTypeText = returnType.getText();

        if (!returnTypeText.includes('Promise')) {
          this.addViolation(file, fn, 'server-action-async',
            'Server actions must be async and return Promise',
            'error'
          );
        }
      });

      if (!filePath.includes('/actions/')) {
        this.addViolation(file, file, 'server-action-location',
          'Server actions must be in /actions/ directory',
          'warning'
        );
      }
    }
  }

  public report(): void {
    if (this.violations.length === 0) {
      console.log('✅ AST Enforcer: No violations found');
      return;
    }

    console.log(`\n❌ Found ${this.violations.length} AST violation(s):\n`);

    const groupedByFile = this.violations.reduce((acc, v) => {
      if (!acc[v.file]) acc[v.file] = [];
      acc[v.file].push(v);
      return acc;
    }, {} as Record<string, Violation[]>);

    Object.entries(groupedByFile).forEach(([file, violations]) => {
      console.log(`\n${file}:`);
      violations.forEach(v => {
        const icon = v.severity === 'error' ? '❌' : '⚠️';
        console.log(`  ${icon} ${v.line}:${v.column} - [${v.rule}] ${v.message}`);
      });
    });

    const errorCount = this.violations.filter(v => v.severity === 'error').length;
    if (errorCount > 0) {
      console.log(`\n❌ ${errorCount} error(s) must be fixed before proceeding`);
      process.exit(1);
    }
  }
}

const enforcer = new ASTEnforcer();
enforcer.enforce();
enforcer.report();
